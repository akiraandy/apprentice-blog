---
layout: post
title: "Webpack"
description: "Pack it up, move it out!"
categories: [code]
tags: [javascript, webpack]
redirect_from:
  - /2018/02/28
---
This week I've been trying to test my frontend JavaScript and I've run into a couple issues that Webpack has helped me solve. Today I'd like to explore some of the high level concepts of Webpack and explain what problems Webpack is trying to solve in the context of development.

In my application, I'm using JQuery and Lodash and although these JavaScript libraries are popular and relatively small in file-size, they still represent large code-bases that aren't native to our applications. External libraries are sometimes referred to as "vendors" (even if the libraries/tools are open-source) and this further hints that these libraries should be kept separate from our source code. It makes our code-base easier to reason about if our 3rd party libraries and tools are not mixed in with our source code. So if we have a public folder with ```application.js``` and our ```application.js``` uses both jQuery and Lodash, can we find a way to use those libraries without having to have ```jquery-x.x.x.js``` and ```lodash.js``` sitting in the same folder?

In HTML we tell the browser what scripts we want executed by creating ```<script>``` tags. In the old days of web development we would have to include all our libraries and source code in multiple ```<script>``` tags which meant we needed to have those files on deck or reference them from an external source. What if we could have all our JavaScript readily available with one ```<script>``` tag? What if we could lazily load<sup>1</sup> our JavaScript? Webpack to the rescue!

On Webpack's website, they define webpack as a "***static module bundler for modern JavaScript applications***". What's a static module? What do they mean by bundler in this case? Well, it's helpful to think of a static module in JavaScript as a traditional class in programming design. Like a class, a static module may have variable and function declarations and it may include other modules (classes). It's basically a container for code! What do they mean by bundler? It's what it sounds like! Webpack will take all the modules you give it and wrap them all up into a bundle or file if you like. Webpack doesn't just bundle JavaScript, it can also bundle .css and images!

There are a couple of advantages that we get from bundling. What if we wanted to have some nifty ES16 features but our browser doesn't understand them? Well, as part of the bundling process what if we ran our .js files through a program that converted those files into .js files that the browser could understand (Babel!)? What if we wanted to reference JS libraries without adding them to our code base? How about when we bundle our .js files, we have our ```import``` statements map to our node_modules installed via ```npm```. That way, we can have access to those great tools without muddying up our code-base. Besides being able to lazily load assets, Webpack also make your exported assets even more efficient by minifying/uglifying them. Compressing assets makes delivery faster! But what if we want to debug even after we've compressed our assets? Webpack allows us to create source-maps of our assets as well! Source-maps is a way to create a reference from a compressed piece of code to that compressed code's uncompressed parent. [This blog post explains what's going on behind the scenes](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/). Webpack makes powerful possibilities available to JavaScript developers and Webpack is part of the reason we can have amazing frameworks like React!

Now I'd just like to go over some of the basic high level concepts of Webpack and break them down a little bit.

Entry:
Webpack understands how all the parts of your application depend on each other by creating a "dependency graph". We need to tell Webpack where our application starts so it can figure out who needs what. You can specify an entry point (or multiple entry points) by configuring the ```entry``` property in the Webpack config file like so:

```
module.exports = {
  entry: './public/javascripts/application.js'
};
```
There are ways to optimize bundling for both single-page and multi-page applications. [Learn more here.](https://webpack.js.org/concepts/entry-points/)

Output:
 When Webpack creates the bundles, how does it know where to put the bundle and what to call it? This is where the output property comes in. You can specify a ```path``` property and a ```filename``` property to tell Webpack where you want the emitted files to be located and what to call them.
```
module.exports = {
  output: {
    filename: 'bundle.js',
    path: '/public/javascripts'
  }
};
```
 To learn more about output you can find out more [here](https://webpack.js.org/concepts/output/).

Loaders:
  How do we tell Webpack to convert our .js files using ES16 features into .js files that the browser can understand? This is where loaders come into play. Loaders allow you to leverage Webpack's bundling capabilities not just for JavaScript files but a plethora of other file types. We just have to tell Webpack what file types to look out for and how to transform them. At a high level, we have two properties that allow us to communicate this to Webpack: ```test``` and ```use```.

  ```
  module: {
    rules: [
      { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" }
    ]
  }
  ```
  In this case, we are telling ```test```, "Hey, when you come across a file ending with ''.js' (a JavaScript file) apply 'babel-loader' to it. Oh, and don't include any files in the node_modules directory. K thx." In the case above, the ```loader``` takes the place of ```use``` but they have the same underlying meaning. Learn more about loaders [here](https://webpack.js.org/concepts/loaders/).

Plugins:
  Loaders transform files while plugins capture all the tasks everything that can't/don't. Plugins allow you to do anything from bundle optimization all the way to defining environment-like variables. Unlike loaders, plugins must be imported via the ```require``` command and included in the plugins array. There are both native plugins that Webpack comes with and 3rd party plugins.
  ```
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const webpack = require('webpack');
  //...
  plugins: [
    new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
  ```
  Learn more about plugins [here](https://webpack.js.org/concepts/plugins)

I still have a lot to learn about how Webpack works and what's possible with it. However, I think having a high level understanding of what's possible with the tool allows you to both appreciate how well Webpack tackles the problem of bundling and dependency management.

<sup>1</sup> Lazy loading is a design pattern where content is loaded on as-per-needed basis. For example, if I have a database of photos and I want to put them on a webpage, instead of loading ALL the photos all at once, I will wait until the user gets to the end of the current set of photos and then load another set of photos. This translates to better load times.
