---
layout: post
title: "Minimax, Negamax, Alpha-beta pruning"
description: "A post about Vim"
categories: [code]
tags: [minimax, negamax, alpha-beta]
redirect_from:
  - /2018/02/19
---
8th Light asked me to create an unbeatable game of Tic Tac Toe for their application process. I rose to the occasion and diligently built out the command-line application with tests to ensure that my computer player couldn’t be beaten. I created the game with a set of rules to follow in throughout the game. The game was done finally and I sent it off to an 8th Light crafter to review my hard work. I was shocked when my reviewer came back saying he beat my computer in one try! He then suggested I implement the minimax algorithm and ask for another review once that was implemented. Up to that moment I had never heard of minimax let alone ever implemented an algorithm derived from game-theory. I did a lot of research and thanks to a lot of people who have solved the problem before me, I implemented the algorithm (not without a lot of headaches!).

I’d like to take the time during this blog post to go over minimax, not necessarily the ins and outs of it but my big takeaways and epiphanies. I also want to go over Negamax (minimax’s sibling if you will) and alpha-beta pruning (a minimax/negamax optimization).

So what is minimax? It’s an algorithm that plays every possible gamestate from both the perspective of a maximizer (who’s interested in deriving the maximum value from a move) and the minimizer (who is also a maximizer but we value this actor’s perspective negatively). This algorithm assumes a zero-sum game, which means that any value of a move made by me represents the opposite value for all of my opponents. If we think about this mathematically: If I make a move valued at 10 points, this represents -10 points from my opponents point of view (summing these values up we get zero, hence a zero-sum game). If we can think of moves as having point values associated with them, and we have some method of finding out the best and worst move-values given any game state, we can create an unbeatable A.I..

The most difficult part for me was understanding that in minimax we are looking at the gamestate from the perspective of BOTH players and both players are assuming the other player will make the best possible move available to them. Also, recursion is hard but this simple idea help me wraps my head around it: Each of these spaces has a value (we don’t know what that value is yet) but we can to find out what that value is by playing out all possible moves if we move into that space and determining what our best and worst outcomes are. When we reach a terminal game state, we have to look at WHO made the winning move for this particular space, this determines whether we assign our maximum values for the space or the minimum value for that space.

Negamax works from just the perspective of the actor running the algorithm. Because negamax assumes a zero-sum game, we can assume that values are opposite of each other. Again, if I make a move that is worth 10 points, that represents -10 points for my opponent, if my opponent makes a move worth 10 points, that’s -10 points for me. This makes implementation easier because in minimax we require the maximizer to select the maximum value move while we make the minimizer choose the minimum value move. Basically in minmax we are more explicit about who the players are and in negamax we treat players like values either assigning a positive spin to their values if they represent us (the maximizer) or a negative spin to their values (if they represent our opponent or minimizer).

Alpha-beta pruning is a little difficult for me to understand but this talk helped a lot: https://youtu.be/STjW3eH0Cik
It’s helpful to think of alpha-beta pruning as a “shrink-wrap” around the node tree of a minimax/negamax algorithm. Any values found outside of alpha or beta are discarded and so entire branches of the node tree are not executed because it keeps track of what the best the maximizer and minimizer could get so far in terms of values. In the future I want to do a deeper dive into alpha-beta pruning but for now, it helps if you think about it as a ceiling and floor for your maximizer and minimizer that helps the efficiency of the algorithm by excluding segments of the search tree.
